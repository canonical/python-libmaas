{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to MAAS's new command-line tool & Python client library python-libmaas provides: A command-line tool for working with MAAS servers. A rich and stable Python client library for interacting with MAAS 2.0+ servers. This can be used in a synchronous/blocking mode, or an asynchronous/non-blocking mode based on asyncio . A lower-level Python client library, auto-generated to match the MAAS server it\u2019s interacting with. For MAAS server documentation, visit docs.ubuntu.com . This is ALPHA software. We are converging on a finished product, but until we release a beta all APIs could change. Installation Either work from a branch: $ git clone https://github.com/maas/python-libmaas.git $ cd python-libmaas $ make Or install with pip into a virtualenv : $ virtualenv --python = python3 amc && source amc/bin/activate $ pip install git+https://github.com/maas/python-libmaas.git Or install from PyPI : $ virtualenv --python = python3 amc && source amc/bin/activate $ pip install python-libmaas Note that PyPI may lag the others. This documentation assumes you\u2019re working from a branch or in a virtualenv. In practice this means it will use partially qualified paths like bin/maas instead of bare maas invocations. If you\u2019ve installed from PyPI the maas command will probably be installed on your shell\u2019s PATH so you can invoke it as maas . Command-line Best place to start with the CLI is the help menu. $ bin/maas help $ bin/maas help commands Once your have familiarized yourself with the available commands you will want to login to your MAAS. You can either pass arguments to login or it will ask your for the needed information to login. $ bin/maas login The CLI supports multiple profiles with login . Use profiles and switch to view and change between profiles. $ bin/maas profiles \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Profile \u2502 URL \u2502 Active \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 admin \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2713 \u2502 \u2502 other \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas switch other $ bin/maas profiles \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Profile \u2502 URL \u2502 Active \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 admin \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2502 \u2502 other \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2713 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The nodes , machines , devices , and controllers provide access to either all nodes with nodes or specific node types with machines , devices , and controllers . $ bin/maas nodes \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 Type \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 another \u2502 Device \u2502 \u2502 blake-ubnt-desktop \u2502 Regiond+rackd \u2502 \u2502 testing \u2502 Device \u2502 \u2502 win2016 \u2502 Machine \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas machines \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 Power \u2502 Status \u2502 Arch \u2502 #CPUs \u2502 RAM \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 win2016 \u2502 Off \u2502 Broken \u2502 amd64 \u2502 4 \u2502 8.0 GB \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas devices \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 IP addresses \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 another \u2502 192.168.1.223 \u2502 \u2502 testing \u2502 192.168.1.150 \u2502 \u2502 \u2502 192.168.1.143 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas controllers \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 Type \u2502 Arch \u2502 #CPUs \u2502 RAM \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 blake-ubnt-desktop \u2502 Regiond+rackd \u2502 amd64 \u2502 8 \u2502 24.0 GB \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Tab-completion in bash and tcsh is supported too. For example, in bash : $ source < ( bin/register-python-argcomplete --shell = bash bin/maas ) $ bin/maas <tab> allocate files login nodes shell ... Client library For a developer the simplest entry points into python-libmaas are the connect and login functions in maas.client . The former connects to a MAAS server using a previously obtained API key, and the latter logs-in to MAAS with your username and password. These returns a Client object that has convenient attributes for working with MAAS. For example, this prints out all interfaces on all machines: from maas.client import login client = login ( \"http://localhost:5240/MAAS/\" , username = \"my_user\" , password = \"my_pass\" , ) tmpl = \" {0.hostname} {1.name} {1.mac_address} \" for machine in client . machines . list (): for interface in machine . interfaces : print ( tmpl . format ( machine , interface )) Learn more about the client . Shell There\u2019s an interactive shell. If a profile name is given or a default profile has been set \u2014 see maas profiles --help \u2014 this places a Client instance in the default namespace (as client ) that you can use interactively or in a script. For the best experience install IPython first. $ bin/maas shell Welcome to the MAAS shell. ... >>> origin . Version . read () <Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]> >>> dir ( client ) [..., 'account', 'boot_resources', ...] Scripts can also be run. For example, given the following script.py : print ( \"Machines:\" , len ( client . machines . list ())) print ( \"Devices:\" , len ( client . devices . list ())) print ( \"Racks:\" , len ( client . rack_controllers . list ())) print ( \"Regions:\" , len ( client . region_controllers . list ())) the following will run it against the default profile: $ bin/maas shell script.py Machines: 1 Devices: 0 Racks: 2 Regions: 1 Development It\u2019s easy to start hacking on python-libmaas : $ git clone git@github.com:maas/python-libmaas.git $ cd python-libmaas $ make develop $ make test Installing IPython is generally a good idea too: $ bin/pip install -UI IPython Pull requests are welcome but authors need to sign the Canonical contributor license agreement before those PRs can be merged.","title":"Home"},{"location":"index.html#installation","text":"Either work from a branch: $ git clone https://github.com/maas/python-libmaas.git $ cd python-libmaas $ make Or install with pip into a virtualenv : $ virtualenv --python = python3 amc && source amc/bin/activate $ pip install git+https://github.com/maas/python-libmaas.git Or install from PyPI : $ virtualenv --python = python3 amc && source amc/bin/activate $ pip install python-libmaas Note that PyPI may lag the others. This documentation assumes you\u2019re working from a branch or in a virtualenv. In practice this means it will use partially qualified paths like bin/maas instead of bare maas invocations. If you\u2019ve installed from PyPI the maas command will probably be installed on your shell\u2019s PATH so you can invoke it as maas .","title":"Installation"},{"location":"index.html#command-line","text":"Best place to start with the CLI is the help menu. $ bin/maas help $ bin/maas help commands Once your have familiarized yourself with the available commands you will want to login to your MAAS. You can either pass arguments to login or it will ask your for the needed information to login. $ bin/maas login The CLI supports multiple profiles with login . Use profiles and switch to view and change between profiles. $ bin/maas profiles \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Profile \u2502 URL \u2502 Active \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 admin \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2713 \u2502 \u2502 other \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas switch other $ bin/maas profiles \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Profile \u2502 URL \u2502 Active \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 admin \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2502 \u2502 other \u2502 http://localhost:5240/MAAS/api/2.0/ \u2502 \u2713 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The nodes , machines , devices , and controllers provide access to either all nodes with nodes or specific node types with machines , devices , and controllers . $ bin/maas nodes \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 Type \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 another \u2502 Device \u2502 \u2502 blake-ubnt-desktop \u2502 Regiond+rackd \u2502 \u2502 testing \u2502 Device \u2502 \u2502 win2016 \u2502 Machine \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas machines \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 Power \u2502 Status \u2502 Arch \u2502 #CPUs \u2502 RAM \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 win2016 \u2502 Off \u2502 Broken \u2502 amd64 \u2502 4 \u2502 8.0 GB \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas devices \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 IP addresses \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 another \u2502 192.168.1.223 \u2502 \u2502 testing \u2502 192.168.1.150 \u2502 \u2502 \u2502 192.168.1.143 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 $ bin/maas controllers \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Hostname \u2502 Type \u2502 Arch \u2502 #CPUs \u2502 RAM \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 blake-ubnt-desktop \u2502 Regiond+rackd \u2502 amd64 \u2502 8 \u2502 24.0 GB \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Tab-completion in bash and tcsh is supported too. For example, in bash : $ source < ( bin/register-python-argcomplete --shell = bash bin/maas ) $ bin/maas <tab> allocate files login nodes shell ...","title":"Command-line"},{"location":"index.html#client-library","text":"For a developer the simplest entry points into python-libmaas are the connect and login functions in maas.client . The former connects to a MAAS server using a previously obtained API key, and the latter logs-in to MAAS with your username and password. These returns a Client object that has convenient attributes for working with MAAS. For example, this prints out all interfaces on all machines: from maas.client import login client = login ( \"http://localhost:5240/MAAS/\" , username = \"my_user\" , password = \"my_pass\" , ) tmpl = \" {0.hostname} {1.name} {1.mac_address} \" for machine in client . machines . list (): for interface in machine . interfaces : print ( tmpl . format ( machine , interface )) Learn more about the client .","title":"Client library"},{"location":"index.html#shell","text":"There\u2019s an interactive shell. If a profile name is given or a default profile has been set \u2014 see maas profiles --help \u2014 this places a Client instance in the default namespace (as client ) that you can use interactively or in a script. For the best experience install IPython first. $ bin/maas shell Welcome to the MAAS shell. ... >>> origin . Version . read () <Version 2.2.0 beta2+bzr5717 [bridging-automatic-ubuntu ...]> >>> dir ( client ) [..., 'account', 'boot_resources', ...] Scripts can also be run. For example, given the following script.py : print ( \"Machines:\" , len ( client . machines . list ())) print ( \"Devices:\" , len ( client . devices . list ())) print ( \"Racks:\" , len ( client . rack_controllers . list ())) print ( \"Regions:\" , len ( client . region_controllers . list ())) the following will run it against the default profile: $ bin/maas shell script.py Machines: 1 Devices: 0 Racks: 2 Regions: 1","title":"Shell"},{"location":"index.html#development","text":"It\u2019s easy to start hacking on python-libmaas : $ git clone git@github.com:maas/python-libmaas.git $ cd python-libmaas $ make develop $ make test Installing IPython is generally a good idea too: $ bin/pip install -UI IPython Pull requests are welcome but authors need to sign the Canonical contributor license agreement before those PRs can be merged.","title":"Development"},{"location":"client/index.html","text":"The Web API client Calling maas.client.connect or maas.client.login (MAAS 2.2+ only) will return a maas.client.facade.Client instance. This provides an easy to understand starting point for working with MAAS\u2019s Web API. An example #!/usr/bin/env python3.6 import maas.client # Replace \u2026 with an API key previously obtained by hand from # http://$host:$port/MAAS/account/prefs/. client = maas . client . connect ( \"http://localhost:5240/MAAS/\" , apikey = \"\u2026\" ) # Get a reference to self. myself = client . users . whoami () assert myself . is_admin , \" %s is not an admin\" % myself . username # Check for a MAAS server capability. version = client . version . get () assert \"devices-management\" in version . capabilities # Check the default OS and distro series for deployments. print ( client . maas . get_default_os ()) print ( client . maas . get_default_distro_series ()) # Set the HTTP proxy. client . maas . set_http_proxy ( \"http://localhost:3128\" ) # Allocate and deploy a machine. machine = client . machines . allocate () machine . deploy () Using login Alternatively, a client can be obtained from a username and password, replacing the call to connect above. This only works in MAAS 2.2 and above; below that a LoginNotSupported exception will be raised. client = login ( \"http://localhost:5240/MAAS/\" , username = \"foo\" , password = \"bar\" , ) Again, but asynchronous At first glance python-libmaas appears to be a blocking API, but it\u2019s actually asynchronous under the skin, based on asyncio . If you call into python-libmaas from within a running event loop it will behave asynchronously, but called from outside it behaves synchronously, and blocks. Using python-libmaas interactively, when exploring the library or trying something out, is familiar and natural because it behaves as a synchronous, blocking API. This mode can be used of in scripts too, but the same code can be easily repurposed for use in an asynchronous, non-blocking application. Below shows the earlier example but implemented in an asynchronous style. Note the use of the asynchronous decorator: this is used heavily in python-libmaas \u2014 along with the Asynchronous metaclass \u2014 to create the automatic blocking/not-blocking behaviour. #!/usr/bin/env python3.6 from maas.client import login from maas.client.utils.async import asynchronous @asynchronous async def work_with_maas (): client = await login ( \"http://eucula.local:5240/MAAS/\" , username = \"gavin\" , password = \"f00b4r\" ) # Get a reference to self. myself = await client . users . whoami () assert myself . is_admin , \" %s is not an admin\" % myself . username # Check for a MAAS server capability. version = await client . version . get () assert \"devices-management\" in version . capabilities # Check the default OS and distro series for deployments. print ( await client . maas . get_default_os ()) print ( await client . maas . get_default_distro_series ()) # Set the HTTP proxy. await client . maas . set_http_proxy ( \"http://localhost:3128\" ) # Allocate and deploy a machine. machine = await client . machines . allocate () await machine . deploy () work_with_maas ()","title":"Introduction"},{"location":"client/index.html#an-example","text":"#!/usr/bin/env python3.6 import maas.client # Replace \u2026 with an API key previously obtained by hand from # http://$host:$port/MAAS/account/prefs/. client = maas . client . connect ( \"http://localhost:5240/MAAS/\" , apikey = \"\u2026\" ) # Get a reference to self. myself = client . users . whoami () assert myself . is_admin , \" %s is not an admin\" % myself . username # Check for a MAAS server capability. version = client . version . get () assert \"devices-management\" in version . capabilities # Check the default OS and distro series for deployments. print ( client . maas . get_default_os ()) print ( client . maas . get_default_distro_series ()) # Set the HTTP proxy. client . maas . set_http_proxy ( \"http://localhost:3128\" ) # Allocate and deploy a machine. machine = client . machines . allocate () machine . deploy ()","title":"An example"},{"location":"client/index.html#using-login","text":"Alternatively, a client can be obtained from a username and password, replacing the call to connect above. This only works in MAAS 2.2 and above; below that a LoginNotSupported exception will be raised. client = login ( \"http://localhost:5240/MAAS/\" , username = \"foo\" , password = \"bar\" , )","title":"Using login"},{"location":"client/index.html#again-but-asynchronous","text":"At first glance python-libmaas appears to be a blocking API, but it\u2019s actually asynchronous under the skin, based on asyncio . If you call into python-libmaas from within a running event loop it will behave asynchronously, but called from outside it behaves synchronously, and blocks. Using python-libmaas interactively, when exploring the library or trying something out, is familiar and natural because it behaves as a synchronous, blocking API. This mode can be used of in scripts too, but the same code can be easily repurposed for use in an asynchronous, non-blocking application. Below shows the earlier example but implemented in an asynchronous style. Note the use of the asynchronous decorator: this is used heavily in python-libmaas \u2014 along with the Asynchronous metaclass \u2014 to create the automatic blocking/not-blocking behaviour. #!/usr/bin/env python3.6 from maas.client import login from maas.client.utils.async import asynchronous @asynchronous async def work_with_maas (): client = await login ( \"http://eucula.local:5240/MAAS/\" , username = \"gavin\" , password = \"f00b4r\" ) # Get a reference to self. myself = await client . users . whoami () assert myself . is_admin , \" %s is not an admin\" % myself . username # Check for a MAAS server capability. version = await client . version . get () assert \"devices-management\" in version . capabilities # Check the default OS and distro series for deployments. print ( await client . maas . get_default_os ()) print ( await client . maas . get_default_distro_series ()) # Set the HTTP proxy. await client . maas . set_http_proxy ( \"http://localhost:3128\" ) # Allocate and deploy a machine. machine = await client . machines . allocate () await machine . deploy () work_with_maas ()","title":"Again, but asynchronous"},{"location":"client/events.html","text":"Events Events are similar to other client objects\u2026 but a little different too. The only way to get events is by the query method: >>> events = client . events . query () This accepts a plethora of optional arguments to narrow down the results: >>> events = client . events . query ( hostnames = { \"foo\" , \"bar\" }) >>> events = client . events . query ( domains = { \"example.com\" , \"maas.io\" }) >>> events = client . events . query ( zones = [ \"red\" , \"blue\" ]) >>> events = client . events . query ( macs = ( \"12:34:56:78:90:ab\" , )) >>> events = client . events . query ( system_ids = \u2026 ) >>> events = client . events . query ( agent_name = \u2026 ) >>> events = client . events . query ( level = \u2026 ) >>> events = client . events . query ( after = \u2026 , limit = \u2026 ) >>> events = client . events . query ( owner = \u2026 ) These arguments can be combined to narrow the results even further. The level argument is a little special. It\u2019s a choice from a predefined set. For convenience, those choices are available in client.events : >>> events = client . events . query ( level = client . events . ERROR ) but you can also pass in the string \u201cERROR\u201d or the number 40.","title":"Events"},{"location":"client/interfaces.html","text":"Interfaces Given an Node instance bound to your MAAS server, you can view and modify its interface configuration. This applies to all Machine , Device , RackController , and RegionController . Read interfaces All Node objects have an interfaces property that provide a sequence of all Interface \u2018s on the Node . >>> machine . interfaces <Interfaces.Managed#Machine length=1 items=[ <Interface mac_address='52:54:00:b4:7e:8c' name='ens3' type=<InterfaceType.PHYSICAL: 'physical'>>]> >>> machine . boot_interface <Interface mac_address='52:54:00:b4:7e:8c' name='ens3' type=<InterfaceType.PHYSICAL: 'physical'>> On bond, VLAN, and bridge interfaces you can get the parents that make the interface. You can also go the other direction and view the children interfaces that are using this interface. Note: Parent and children objects are unloaded so they must be loaded to access the properties of the object. >>> bond . parents <Interfaces.Managed#Interface length=2 items=[ <Interface name='ens3' node=<Node system_id='yr7fym' (unloaded)> (unloaded)>, <Interface name='ens4' node=<Node system_id='yr7fym' (unloaded)> (unloaded)>, ]> >>> ens3 = bond . parents [ 0 ] >>> ens3 . loaded False >>> ens3 . refresh () >>> ens3 . type <InterfaceType.PHYSICAL: 'physical'> >>> ens3 . children <Interfaces.Managed#Interface length=1 items=[ <Interface name='bond0' node=<Node system_id='yr7fym' (unloaded)> (unloaded)>, ]> Get interface by name The interfaces property on Node gives you access to all interfaces on the node. Sometimes you want to access the interface objects by name. by_name and get_by_name are helpers on Interfaces that help. >>> machine . interfaces . by_name {'bond0': <Interface mac_address='52:54:00:b4:7e:8c' name='bond0' type=<InterfaceType.BOND: 'bond'>>, 'ens3': <Interface mac_address='52:54:00:b4:7e:8c' name='ens3' type=<InterfaceType.PHYSICAL: 'physical'>>, 'ens8': <Interface mac_address='52:54:00:11:f3:d2' name='ens8' type=<InterfaceType.PHYSICAL: 'physical'>>} >>> bond = machine . interfaces . get_by_name ( 'bond0' ) >>> bond <Interface mac_address='52:54:00:b4:7e:8c' name='bond0' type=<InterfaceType.BOND: 'bond'>> Read IP configuration Every Interface has a links property that provides all the IP information on how the interface is configured. >>> bond . links <InterfaceLinks.Managed#Interface length=1 items=[ <InterfaceLink ip_address=None mode=<LinkMode.AUTO: 'auto'> subnet=<Subnet cidr='192.168.122.0/24' name='192.168.122.0/24' vlan=<Vlan name='untagged' vid=0>>>]> Create physical Creation of interfaces is done directly on the interfaces property of a Node . Physical interface is the default type for the create method so only mac_address is required. >>> new_phy = machine . interfaces . create ( mac_address = \"00:11:22:aa:bb:cc\" ) >>> new_phy <Interface mac_address='00:11:22:aa:bb:cc' name='eth0' type=<InterfaceType.PHYSICAL: 'physical'>> By default the interface is created disconnected. To create it the interface with it connected to a VLAN pass the vlan parameter. >>> default_vlan = client . fabrics . get_default () . vlans . get_default () >>> new_phy = machine . interfaces . create ( ... mac_address = \"00:11:22:aa:bb:cc\" , vlan = default_vlan ) >>> new_phy <Interface mac_address='00:11:22:aa:bb:cc' name='eth0' type=<InterfaceType.PHYSICAL: 'physical'>> >>> new_phy . vlan <Vlan name='untagged' vid=0> Create bond Bond creation is the same as creating a physical interface but an InterfaceType is provided with options specific for a bond. >>> new_bond = machine . interfaces . create ( ... InterfaceType . BOND , name = 'bond0' , parents = machine . interfaces , ... bond_mode = '802.3ad' ) >>> new_bond <Interface mac_address='52:54:00:b4:7e:8c' name='bond0' type=<InterfaceType.BOND: 'bond'>> >>> new_bond . params {'bond_downdelay': 0, 'bond_lacp_rate': 'slow', 'bond_miimon': 100, 'bond_mode': '802.3ad', 'bond_updelay': 0, 'bond_xmit_hash_policy': 'layer2'} Create vlan VLAN creation only requires a single parent and a tagged VLAN to connect the interface to. >>> default_fabric = client . fabrics . get_default () >>> vlan_10 = default_fabric . vlans . create ( 10 ) >>> vlan_nic = machine . interfaces . create ( ... InterfaceType . VLAN , parent = new_bond , vlan = vlan_10 ) >>> vlan_nic <Interface mac_address='52:54:00:b4:7e:8c' name='bond0.10' type=<InterfaceType.VLAN: 'vlan'>> Create bridge Bridge creation only requires the name and parent interface you want the bridge to be created on. >>> bridge_nic = machine . interfaces . create ( ... InterfaceType . BRIDGE , name = 'br0' , parent = vlan_nic ) >>> bridge_nic <Interface mac_address='52:54:00:b4:7e:8c' name='br0' type=<InterfaceType.BRIDGE: 'bridge'>> Update interface To update an interface just changing the properties of the interface and calling save is all that is required. >>> new_bond . name = 'my-bond' >>> new_bond . params [ 'bond_mode' ] = 'active-backup' >>> new_bond . save () Change IP configuration To adjust the IP configuration on a specific interface create on the links property and delete on the InterfaceLink can be used. >>> new_bond . links . create ( LinkMode . AUTO , subnet = subnet ) <InterfaceLink ip_address=None mode=<LinkMode.AUTO: 'auto'> subnet=<Subnet cidr='192.168.122.0/24' name='192.168.122.0/24' vlan=<Vlan name='untagged' vid=0>>> >>> new_bond . links [ - 1 ] . delete () >>> new_bond . links . create ( ... LinkMode . STATIC , subnet = subnet , ip_address = '192.168.122.1' ) <InterfaceLink ip_address='192.168.122.10' mode=<LinkMode.STATIC: 'static'> subnet=<Subnet cidr='192.168.122.0/24' name='192.168.122.0/24' vlan=<Vlan name='untagged' vid=0>>> >>> new_bond . links [ - 1 ] . delete () Disconnect interface To completely mark an interface as disconnected and remove all configuration the disconnect call makes this easy. >>> new_bond . disconnect () Delete interface delete exists directly on the Interface object so deletion is simple. >>> new_bond . delete ()","title":"Interfaces"},{"location":"client/interfaces.html#read-interfaces","text":"All Node objects have an interfaces property that provide a sequence of all Interface \u2018s on the Node . >>> machine . interfaces <Interfaces.Managed#Machine length=1 items=[ <Interface mac_address='52:54:00:b4:7e:8c' name='ens3' type=<InterfaceType.PHYSICAL: 'physical'>>]> >>> machine . boot_interface <Interface mac_address='52:54:00:b4:7e:8c' name='ens3' type=<InterfaceType.PHYSICAL: 'physical'>> On bond, VLAN, and bridge interfaces you can get the parents that make the interface. You can also go the other direction and view the children interfaces that are using this interface. Note: Parent and children objects are unloaded so they must be loaded to access the properties of the object. >>> bond . parents <Interfaces.Managed#Interface length=2 items=[ <Interface name='ens3' node=<Node system_id='yr7fym' (unloaded)> (unloaded)>, <Interface name='ens4' node=<Node system_id='yr7fym' (unloaded)> (unloaded)>, ]> >>> ens3 = bond . parents [ 0 ] >>> ens3 . loaded False >>> ens3 . refresh () >>> ens3 . type <InterfaceType.PHYSICAL: 'physical'> >>> ens3 . children <Interfaces.Managed#Interface length=1 items=[ <Interface name='bond0' node=<Node system_id='yr7fym' (unloaded)> (unloaded)>, ]>","title":"Read interfaces"},{"location":"client/interfaces.html#get-interface-by-name","text":"The interfaces property on Node gives you access to all interfaces on the node. Sometimes you want to access the interface objects by name. by_name and get_by_name are helpers on Interfaces that help. >>> machine . interfaces . by_name {'bond0': <Interface mac_address='52:54:00:b4:7e:8c' name='bond0' type=<InterfaceType.BOND: 'bond'>>, 'ens3': <Interface mac_address='52:54:00:b4:7e:8c' name='ens3' type=<InterfaceType.PHYSICAL: 'physical'>>, 'ens8': <Interface mac_address='52:54:00:11:f3:d2' name='ens8' type=<InterfaceType.PHYSICAL: 'physical'>>} >>> bond = machine . interfaces . get_by_name ( 'bond0' ) >>> bond <Interface mac_address='52:54:00:b4:7e:8c' name='bond0' type=<InterfaceType.BOND: 'bond'>>","title":"Get interface by name"},{"location":"client/interfaces.html#read-ip-configuration","text":"Every Interface has a links property that provides all the IP information on how the interface is configured. >>> bond . links <InterfaceLinks.Managed#Interface length=1 items=[ <InterfaceLink ip_address=None mode=<LinkMode.AUTO: 'auto'> subnet=<Subnet cidr='192.168.122.0/24' name='192.168.122.0/24' vlan=<Vlan name='untagged' vid=0>>>]>","title":"Read IP configuration"},{"location":"client/interfaces.html#create-physical","text":"Creation of interfaces is done directly on the interfaces property of a Node . Physical interface is the default type for the create method so only mac_address is required. >>> new_phy = machine . interfaces . create ( mac_address = \"00:11:22:aa:bb:cc\" ) >>> new_phy <Interface mac_address='00:11:22:aa:bb:cc' name='eth0' type=<InterfaceType.PHYSICAL: 'physical'>> By default the interface is created disconnected. To create it the interface with it connected to a VLAN pass the vlan parameter. >>> default_vlan = client . fabrics . get_default () . vlans . get_default () >>> new_phy = machine . interfaces . create ( ... mac_address = \"00:11:22:aa:bb:cc\" , vlan = default_vlan ) >>> new_phy <Interface mac_address='00:11:22:aa:bb:cc' name='eth0' type=<InterfaceType.PHYSICAL: 'physical'>> >>> new_phy . vlan <Vlan name='untagged' vid=0>","title":"Create physical"},{"location":"client/interfaces.html#create-bond","text":"Bond creation is the same as creating a physical interface but an InterfaceType is provided with options specific for a bond. >>> new_bond = machine . interfaces . create ( ... InterfaceType . BOND , name = 'bond0' , parents = machine . interfaces , ... bond_mode = '802.3ad' ) >>> new_bond <Interface mac_address='52:54:00:b4:7e:8c' name='bond0' type=<InterfaceType.BOND: 'bond'>> >>> new_bond . params {'bond_downdelay': 0, 'bond_lacp_rate': 'slow', 'bond_miimon': 100, 'bond_mode': '802.3ad', 'bond_updelay': 0, 'bond_xmit_hash_policy': 'layer2'}","title":"Create bond"},{"location":"client/interfaces.html#create-vlan","text":"VLAN creation only requires a single parent and a tagged VLAN to connect the interface to. >>> default_fabric = client . fabrics . get_default () >>> vlan_10 = default_fabric . vlans . create ( 10 ) >>> vlan_nic = machine . interfaces . create ( ... InterfaceType . VLAN , parent = new_bond , vlan = vlan_10 ) >>> vlan_nic <Interface mac_address='52:54:00:b4:7e:8c' name='bond0.10' type=<InterfaceType.VLAN: 'vlan'>>","title":"Create vlan"},{"location":"client/interfaces.html#create-bridge","text":"Bridge creation only requires the name and parent interface you want the bridge to be created on. >>> bridge_nic = machine . interfaces . create ( ... InterfaceType . BRIDGE , name = 'br0' , parent = vlan_nic ) >>> bridge_nic <Interface mac_address='52:54:00:b4:7e:8c' name='br0' type=<InterfaceType.BRIDGE: 'bridge'>>","title":"Create bridge"},{"location":"client/interfaces.html#update-interface","text":"To update an interface just changing the properties of the interface and calling save is all that is required. >>> new_bond . name = 'my-bond' >>> new_bond . params [ 'bond_mode' ] = 'active-backup' >>> new_bond . save ()","title":"Update interface"},{"location":"client/interfaces.html#change-ip-configuration","text":"To adjust the IP configuration on a specific interface create on the links property and delete on the InterfaceLink can be used. >>> new_bond . links . create ( LinkMode . AUTO , subnet = subnet ) <InterfaceLink ip_address=None mode=<LinkMode.AUTO: 'auto'> subnet=<Subnet cidr='192.168.122.0/24' name='192.168.122.0/24' vlan=<Vlan name='untagged' vid=0>>> >>> new_bond . links [ - 1 ] . delete () >>> new_bond . links . create ( ... LinkMode . STATIC , subnet = subnet , ip_address = '192.168.122.1' ) <InterfaceLink ip_address='192.168.122.10' mode=<LinkMode.STATIC: 'static'> subnet=<Subnet cidr='192.168.122.0/24' name='192.168.122.0/24' vlan=<Vlan name='untagged' vid=0>>> >>> new_bond . links [ - 1 ] . delete ()","title":"Change IP configuration"},{"location":"client/interfaces.html#disconnect-interface","text":"To completely mark an interface as disconnected and remove all configuration the disconnect call makes this easy. >>> new_bond . disconnect ()","title":"Disconnect interface"},{"location":"client/interfaces.html#delete-interface","text":"delete exists directly on the Interface object so deletion is simple. >>> new_bond . delete ()","title":"Delete interface"},{"location":"client/networking.html","text":"Fabrics, VLANs, Subnets, Spaces, IP Ranges, Static Routes Given a Client instance bound to your MAAS server, you can interrogate your entire networking configuration. Read networking fabrics , subnets , spaces , ip_ranges , and static_routes is exposed directly on your Client instance. vlans are nested under each Fabric . >>> fabrics = client . fabrics . list () >>> len ( fabrics ) 1 >>> default_fabric = fabrics . get_default () >>> default_fabric . name 'fabric-0' >>> default_fabric . vlans <Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]> >>> for vlan in default_fabric . vlans : ... print ( vlan ) ... <Vlan name='untagged' vid=0> >>> Get a specific subnet and view the Vlan and Fabric that it is assigned to. Going up the tree from Vlan to Fabric results in an unloaded Fabric . Calling refresh on Fabric will load the object from MAAS. >>> vm_subnet = client . subnets . get ( '192.168.122.0/24' ) >>> vm_subnet . cidr '192.168.122.0/24' >>> vm_subnet . vlan <Vlan name='untagged' vid=0> >>> fabric = vm_subnet . vlan . fabric >>> fabric <Fabric id=20 (unloaded)> >>> fabric . refresh () >>> fabric . vlans Traceback (most recent call last): ... ObjectNotLoaded : cannot access attribute 'vlans' of object 'Fabric' >>> fabric . is_loaded False >>> fabric . refresh () >>> fabric . is_loaded True >>> fabric . vlans <Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]> Access to spaces , ip_ranges , and static_routes works similarly. >>> client . spaces . list () >>> client . ip_ranges . list () >>> client . static_routes . list () Create fabric & vlan Creating a new fabric and vlan is done directly from each set of objects on the Client respectively. >>> new_fabric = client . fabrics . create () >>> new_fabric . name 'fabric-2' >>> new_vlan = new_fabric . vlans . create ( 20 ) >>> new_vlan <Vlan name='' vid=20> >>> new_vlan . fabric <Fabric id=2 (unloaded)> Create subnet Create a new subnet and assign it to an existing vlan. >>> new_subnet = client . subnets . create ( '192.168.128.0/24' , new_vlan ) >>> new_subnet . cidr '192.168.128.0/24' >>> new_subnet . vlan <Vlan name='' vid=20> Update subnet Quickly move the newly created subnet from vlan to default fabric untagged vlan. >>> default_fabric = client . fabrics . get_default () >>> untagged = default_fabric . vlans . get_default () >>> new_subnet . vlan = untagged >>> new_subnet . save () >>> new_subnet . vlan <Vlan name='untagged' vid=0> Delete subnet delete exists directly on the Subnet object so deletion is simple. >>> new_subnet . delete () >>> Enable DHCP Create a new dynamic IP range and turn DHCP on the selected rack controller. >>> fabric = client . fabrics . get_default () >>> untagged = fabric . vlans . get_default () >>> new_range = client . ip_ranges . create ( ... '192.168.122.100' , '192.168.122.200' , type = IPRangeType . DYNAMIC ) >>> rack = client . rack_controllers . list ()[ 0 ] >>> untagged . dhcp_on = True >>> untagged . primary_rack = rack >>> untagged . save ()","title":"Networking"},{"location":"client/networking.html#read-networking","text":"fabrics , subnets , spaces , ip_ranges , and static_routes is exposed directly on your Client instance. vlans are nested under each Fabric . >>> fabrics = client . fabrics . list () >>> len ( fabrics ) 1 >>> default_fabric = fabrics . get_default () >>> default_fabric . name 'fabric-0' >>> default_fabric . vlans <Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]> >>> for vlan in default_fabric . vlans : ... print ( vlan ) ... <Vlan name='untagged' vid=0> >>> Get a specific subnet and view the Vlan and Fabric that it is assigned to. Going up the tree from Vlan to Fabric results in an unloaded Fabric . Calling refresh on Fabric will load the object from MAAS. >>> vm_subnet = client . subnets . get ( '192.168.122.0/24' ) >>> vm_subnet . cidr '192.168.122.0/24' >>> vm_subnet . vlan <Vlan name='untagged' vid=0> >>> fabric = vm_subnet . vlan . fabric >>> fabric <Fabric id=20 (unloaded)> >>> fabric . refresh () >>> fabric . vlans Traceback (most recent call last): ... ObjectNotLoaded : cannot access attribute 'vlans' of object 'Fabric' >>> fabric . is_loaded False >>> fabric . refresh () >>> fabric . is_loaded True >>> fabric . vlans <Vlans.Managed#Fabric length=1 items=[<Vlan name='untagged' vid=0>]> Access to spaces , ip_ranges , and static_routes works similarly. >>> client . spaces . list () >>> client . ip_ranges . list () >>> client . static_routes . list ()","title":"Read networking"},{"location":"client/networking.html#create-fabric-vlan","text":"Creating a new fabric and vlan is done directly from each set of objects on the Client respectively. >>> new_fabric = client . fabrics . create () >>> new_fabric . name 'fabric-2' >>> new_vlan = new_fabric . vlans . create ( 20 ) >>> new_vlan <Vlan name='' vid=20> >>> new_vlan . fabric <Fabric id=2 (unloaded)>","title":"Create fabric &amp; vlan"},{"location":"client/networking.html#create-subnet","text":"Create a new subnet and assign it to an existing vlan. >>> new_subnet = client . subnets . create ( '192.168.128.0/24' , new_vlan ) >>> new_subnet . cidr '192.168.128.0/24' >>> new_subnet . vlan <Vlan name='' vid=20>","title":"Create subnet"},{"location":"client/networking.html#update-subnet","text":"Quickly move the newly created subnet from vlan to default fabric untagged vlan. >>> default_fabric = client . fabrics . get_default () >>> untagged = default_fabric . vlans . get_default () >>> new_subnet . vlan = untagged >>> new_subnet . save () >>> new_subnet . vlan <Vlan name='untagged' vid=0>","title":"Update subnet"},{"location":"client/networking.html#delete-subnet","text":"delete exists directly on the Subnet object so deletion is simple. >>> new_subnet . delete () >>>","title":"Delete subnet"},{"location":"client/networking.html#enable-dhcp","text":"Create a new dynamic IP range and turn DHCP on the selected rack controller. >>> fabric = client . fabrics . get_default () >>> untagged = fabric . vlans . get_default () >>> new_range = client . ip_ranges . create ( ... '192.168.122.100' , '192.168.122.200' , type = IPRangeType . DYNAMIC ) >>> rack = client . rack_controllers . list ()[ 0 ] >>> untagged . dhcp_on = True >>> untagged . primary_rack = rack >>> untagged . save ()","title":"Enable DHCP"},{"location":"client/nodes.html","text":"Machines, devices, racks, and regions Given a Client instance bound to your MAAS server, you can interrogate your nodes. Read nodes Each node type exists on the client: machines , devices , rack_controllers , region_controllers . >>> client . machines . list () <Machines length=1 items=[<Machine hostname='wanted-falcon' system_id='ekgqwd'>]> >>> client . devices . list () <Devices length=0 items=[]> >>> client . rack_controllers . list () <RackControllers length=1 items=[<RackController hostname='maas-ctrl' system_id='efw3c4'>]> >>> client . region_controllers . list () <RegionControllers length=1 items=[<RegionController hostname='maas-ctrl' system_id='efw3c4'>]> Easily iterate through the machines. >>> for machine in client . machines . list (): ... print ( repr ( machine )) <Machine hostname='botswana' system_id='pncys4'> Get a machine from its system_id. >>> machine = client . machines . get ( system_id = \"pncys4\" ) >>> machine <Machine hostname='botswana' system_id='pncys4'> Machines \u2014 and devices, racks, and regions \u2014 have many useful attributes: >>> machine . architecture 'amd64/generic' >>> machine . cpus 4 Don\u2019t forget to try using tab-completion \u2014 the objects have been designed to be particularly friendly for interactive use \u2014 or dir(machine) to find out what other fields and methods are available. Create nodes Create a machine in MAAS. The architecture, MAC addresses, and power type are required fields. >>> machine = client . machines . create ( ... \"amd64\" , [ \"00:11:22:33:44:55\" , \"AA:BB:CC:DD:EE:FF\" ], \"manual\" ) <Machine hostname='wanted-falcon' system_id='ekgqwd'> Normally you need to pass in power parameter so MAAS can talk to the BMC. >>> machine = client . machines . create ( ... \"amd64\" , [ \"00:11:22:33:44:55\" , \"AA:BB:CC:DD:EE:FF\" ], \"ipmi\" , { ... \"power_address\" : \"10.245.0.10\" , ... \"power_user\" : \"root\" , ... \"power_pass\" : \"calvin\" , ... }) >>> machine <Machine hostname='wanted-falcon' system_id='ekgqwd'> >>> machine . status <NodeStatus.COMMISSIONING: 1> Updating nodes Updating a machine is as simple as modifying the attribute and saving. >>> machine . hostname = 'my-machine' >>> machine . architecture = 'i386/generic' >>> machine . save () Deleting nodes Delete a machine is simple as calling delete on the machine object. >>> machine . delete () Assigning tags Assigning tags to a machine is as simple as calling add or remove on tags attribute. >>> new_tag = client . tags . create ( 'new' ) >>> machine . tags . add ( new_tag ) >>> machine . tags <Tags.Managed#Machine length=1 items=[<Tag name='new' (unloaded)>]> >>> machine . tags . remove ( new_tag ) Commissioning and testing Easily commission a machine and wait until it successfully completes. By default the commission method waits until commissioning succeeds. >>> machine . commission () >>> machine . status NodeStatus.READY A more advanced asyncio based script that runs commissioning with extra scripts and waits until all machines have successfully commissioned. #!/usr/bin/env python3 import asyncio from maas.client import login from maas.client.enum import NodeStatus from maas.client.utils.async import asynchronous @asynchronous async def commission_all_machines (): client = await login ( \"http://eucula.local:5240/MAAS/\" , username = \"gavin\" , password = \"f00b4r\" ) # Get all machines that are in the NEW status. all_machines = await client . machines . list () new_machines = [ machine for machine in all_machines if machine . status == NodeStatus . NEW ] # Run commissioning with a custom commissioning script on all new machines. for machine in new_machines : machine . commission ( commissioning_scripts = [ 'clear_hardware_raid' ], wait = False ) # Wait until all machines are ready. failed_machines = [] completed_machines = [] while len ( new_machines ) > 0 : await asyncio . sleep ( 5 ) for machine in list ( new_machines ): await machine . refresh () if machine . status in [ NodeStatus . COMMISSIONING , NodeStatus . TESTING ]: # Machine is still commissioning or testing. continue elif machine . status == NodeStatus . READY : # Machine is complete. completed_machines . append ( machine ) new_machines . remove ( machine ) else : # Machine has failed commissioning. failed_machines . append ( machine ) new_machines . remove ( machine ) # Print message if any machines failed to commission. if len ( failed_machines ) > 0 : for machine in failed_machines : print ( \" %s : transitioned to unexpected status - %s \" % ( machine . hostname , machine . status_name )) else : print ( \"Successfully commissioned %d machines.\" % len ( completed_machines )) commission_all_machines () Allocating and deploying >>> help ( client . machines . allocate ) Help on method allocate in module maas.client.viscera.machines: allocate( *, hostname:str=None, architecture:str=None, cpus:int=None, memory:float=None, tags:typing.Sequence=None) method of maas.client.viscera.machines.MachinesType instance Allocate a machine. :param hostname: The hostname to match. :param architecture: The architecture to match, e.g. \"amd64\". :param cpus: The minimum number of CPUs to match. :param memory: The minimum amount of RAM to match. :param tags: The tags to match, as a sequence. Each tag may be prefixed with a hyphen to denote that the given tag should NOT be associated with a matched machine. >>> machine = client . machines . allocate ( tags = ( \"foo\" , \"-bar\" )) >>> print ( machine . status ) NodeStatus.COMMISSIONING >>> machine . deploy () >>> print ( machine . status ) NodeStatus.DEPLOYING Abort If an action is performed on a machine and it needs to be aborted before it finishes abort can be used. >>> machine . commission ( wait = False ) >>> machine . status NodeStatus.COMMISSIONING >>> machine . abort () >>> machine . status NodeStatus.NEW Rescue mode Boot the machine into rescue mode and then exit. >>> machine . enter_rescue_mode () >>> machine . exit_rescue_mode () Broken & Fixed When a machine is identified as broken you can easily mark it broken and then fixed once the issue is resolved. >>> machine . mark_broken () >>> machine . status NodeStatus.BROKEN >>> machine . mark_fixed () >>> machine . status NodeStatus.READY Owner Data Owner data is extra information that you can set on a machine to hold some state information. Note: Once the machine is no longer in your control the information will be lost. >>> machine . owner_data {} >>> machine . owner_data [ 'state' ] = 'my-state-info' >>> machine . save () >>> machine . owner_data {'state': 'my-state-info'} >>> machine . release () >>> machine . owner_data {} Power Control The power state of a machine can be controlled outside of deploy, releasing, and rescue mode. If you need to control the power of a BMC independently the power_on , power_off and query_power_state can be of help. >>> machine . power_state PowerState.ON >>> machine . power_off () >>> machine . power_state PowerState.OFF >>> machine . power_on () >>> machine . power_state PowerState.ON >>> machine . query_power_state () PowerState.ON Reset Configuration It is possible to restore the machine back to exactly how it was after you completed commissioning. This is helpful when you have made a configuration that you no longer want or you want to start fresh. >>> machine . restore_default_configuration () >>> # Only restore networking. >>> machine . restore_networking_configuration () >>> # Only restore storage configuration. >>> machine . restore_storage_configuration ()","title":"Nodes"},{"location":"client/nodes.html#read-nodes","text":"Each node type exists on the client: machines , devices , rack_controllers , region_controllers . >>> client . machines . list () <Machines length=1 items=[<Machine hostname='wanted-falcon' system_id='ekgqwd'>]> >>> client . devices . list () <Devices length=0 items=[]> >>> client . rack_controllers . list () <RackControllers length=1 items=[<RackController hostname='maas-ctrl' system_id='efw3c4'>]> >>> client . region_controllers . list () <RegionControllers length=1 items=[<RegionController hostname='maas-ctrl' system_id='efw3c4'>]> Easily iterate through the machines. >>> for machine in client . machines . list (): ... print ( repr ( machine )) <Machine hostname='botswana' system_id='pncys4'> Get a machine from its system_id. >>> machine = client . machines . get ( system_id = \"pncys4\" ) >>> machine <Machine hostname='botswana' system_id='pncys4'> Machines \u2014 and devices, racks, and regions \u2014 have many useful attributes: >>> machine . architecture 'amd64/generic' >>> machine . cpus 4 Don\u2019t forget to try using tab-completion \u2014 the objects have been designed to be particularly friendly for interactive use \u2014 or dir(machine) to find out what other fields and methods are available.","title":"Read nodes"},{"location":"client/nodes.html#create-nodes","text":"Create a machine in MAAS. The architecture, MAC addresses, and power type are required fields. >>> machine = client . machines . create ( ... \"amd64\" , [ \"00:11:22:33:44:55\" , \"AA:BB:CC:DD:EE:FF\" ], \"manual\" ) <Machine hostname='wanted-falcon' system_id='ekgqwd'> Normally you need to pass in power parameter so MAAS can talk to the BMC. >>> machine = client . machines . create ( ... \"amd64\" , [ \"00:11:22:33:44:55\" , \"AA:BB:CC:DD:EE:FF\" ], \"ipmi\" , { ... \"power_address\" : \"10.245.0.10\" , ... \"power_user\" : \"root\" , ... \"power_pass\" : \"calvin\" , ... }) >>> machine <Machine hostname='wanted-falcon' system_id='ekgqwd'> >>> machine . status <NodeStatus.COMMISSIONING: 1>","title":"Create nodes"},{"location":"client/nodes.html#updating-nodes","text":"Updating a machine is as simple as modifying the attribute and saving. >>> machine . hostname = 'my-machine' >>> machine . architecture = 'i386/generic' >>> machine . save ()","title":"Updating nodes"},{"location":"client/nodes.html#deleting-nodes","text":"Delete a machine is simple as calling delete on the machine object. >>> machine . delete ()","title":"Deleting nodes"},{"location":"client/nodes.html#assigning-tags","text":"Assigning tags to a machine is as simple as calling add or remove on tags attribute. >>> new_tag = client . tags . create ( 'new' ) >>> machine . tags . add ( new_tag ) >>> machine . tags <Tags.Managed#Machine length=1 items=[<Tag name='new' (unloaded)>]> >>> machine . tags . remove ( new_tag )","title":"Assigning tags"},{"location":"client/nodes.html#commissioning-and-testing","text":"Easily commission a machine and wait until it successfully completes. By default the commission method waits until commissioning succeeds. >>> machine . commission () >>> machine . status NodeStatus.READY A more advanced asyncio based script that runs commissioning with extra scripts and waits until all machines have successfully commissioned. #!/usr/bin/env python3 import asyncio from maas.client import login from maas.client.enum import NodeStatus from maas.client.utils.async import asynchronous @asynchronous async def commission_all_machines (): client = await login ( \"http://eucula.local:5240/MAAS/\" , username = \"gavin\" , password = \"f00b4r\" ) # Get all machines that are in the NEW status. all_machines = await client . machines . list () new_machines = [ machine for machine in all_machines if machine . status == NodeStatus . NEW ] # Run commissioning with a custom commissioning script on all new machines. for machine in new_machines : machine . commission ( commissioning_scripts = [ 'clear_hardware_raid' ], wait = False ) # Wait until all machines are ready. failed_machines = [] completed_machines = [] while len ( new_machines ) > 0 : await asyncio . sleep ( 5 ) for machine in list ( new_machines ): await machine . refresh () if machine . status in [ NodeStatus . COMMISSIONING , NodeStatus . TESTING ]: # Machine is still commissioning or testing. continue elif machine . status == NodeStatus . READY : # Machine is complete. completed_machines . append ( machine ) new_machines . remove ( machine ) else : # Machine has failed commissioning. failed_machines . append ( machine ) new_machines . remove ( machine ) # Print message if any machines failed to commission. if len ( failed_machines ) > 0 : for machine in failed_machines : print ( \" %s : transitioned to unexpected status - %s \" % ( machine . hostname , machine . status_name )) else : print ( \"Successfully commissioned %d machines.\" % len ( completed_machines )) commission_all_machines ()","title":"Commissioning and testing"},{"location":"client/nodes.html#allocating-and-deploying","text":">>> help ( client . machines . allocate ) Help on method allocate in module maas.client.viscera.machines: allocate( *, hostname:str=None, architecture:str=None, cpus:int=None, memory:float=None, tags:typing.Sequence=None) method of maas.client.viscera.machines.MachinesType instance Allocate a machine. :param hostname: The hostname to match. :param architecture: The architecture to match, e.g. \"amd64\". :param cpus: The minimum number of CPUs to match. :param memory: The minimum amount of RAM to match. :param tags: The tags to match, as a sequence. Each tag may be prefixed with a hyphen to denote that the given tag should NOT be associated with a matched machine. >>> machine = client . machines . allocate ( tags = ( \"foo\" , \"-bar\" )) >>> print ( machine . status ) NodeStatus.COMMISSIONING >>> machine . deploy () >>> print ( machine . status ) NodeStatus.DEPLOYING","title":"Allocating and deploying"},{"location":"client/nodes.html#abort","text":"If an action is performed on a machine and it needs to be aborted before it finishes abort can be used. >>> machine . commission ( wait = False ) >>> machine . status NodeStatus.COMMISSIONING >>> machine . abort () >>> machine . status NodeStatus.NEW","title":"Abort"},{"location":"client/nodes.html#rescue-mode","text":"Boot the machine into rescue mode and then exit. >>> machine . enter_rescue_mode () >>> machine . exit_rescue_mode ()","title":"Rescue mode"},{"location":"client/nodes.html#broken-fixed","text":"When a machine is identified as broken you can easily mark it broken and then fixed once the issue is resolved. >>> machine . mark_broken () >>> machine . status NodeStatus.BROKEN >>> machine . mark_fixed () >>> machine . status NodeStatus.READY","title":"Broken &amp; Fixed"},{"location":"client/nodes.html#owner-data","text":"Owner data is extra information that you can set on a machine to hold some state information. Note: Once the machine is no longer in your control the information will be lost. >>> machine . owner_data {} >>> machine . owner_data [ 'state' ] = 'my-state-info' >>> machine . save () >>> machine . owner_data {'state': 'my-state-info'} >>> machine . release () >>> machine . owner_data {}","title":"Owner Data"},{"location":"client/nodes.html#power-control","text":"The power state of a machine can be controlled outside of deploy, releasing, and rescue mode. If you need to control the power of a BMC independently the power_on , power_off and query_power_state can be of help. >>> machine . power_state PowerState.ON >>> machine . power_off () >>> machine . power_state PowerState.OFF >>> machine . power_on () >>> machine . power_state PowerState.ON >>> machine . query_power_state () PowerState.ON","title":"Power Control"},{"location":"client/nodes.html#reset-configuration","text":"It is possible to restore the machine back to exactly how it was after you completed commissioning. This is helpful when you have made a configuration that you no longer want or you want to start fresh. >>> machine . restore_default_configuration () >>> # Only restore networking. >>> machine . restore_networking_configuration () >>> # Only restore storage configuration. >>> machine . restore_storage_configuration ()","title":"Reset Configuration"},{"location":"client/other.html","text":"Other objects There are several other object types available via the client API. Use dir() and tab-completion to dig around interactively, or read the code; we\u2019ve tried to keep it readable. Files, users, tags Similarly to nodes, these sets of objects can be fetched: >>> tags = client . tags . list () >>> files = client . files . list () >>> users = client . users . list () When reading from collections, as above, the returned object is list-like: >>> len ( tags ) 5 >>> tags [ 3 ] <Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'> >>> tags [ 3 ] in tags True >>> not_foo = [ tag for tag in tags if tag . name != 'foo' ] >>> len ( not_foo ) 4 However, it\u2019s read-only: >>> tags [ 0 ] = \"bob\" \u2026 TypeError: 'Tags' object does not support item assignment","title":"Others"},{"location":"client/other.html#files-users-tags","text":"Similarly to nodes, these sets of objects can be fetched: >>> tags = client . tags . list () >>> files = client . files . list () >>> users = client . users . list () When reading from collections, as above, the returned object is list-like: >>> len ( tags ) 5 >>> tags [ 3 ] <Tag comment=\"Foo's stuff\" definition='' kernel_opts='' name='foo'> >>> tags [ 3 ] in tags True >>> not_foo = [ tag for tag in tags if tag . name != 'foo' ] >>> len ( not_foo ) 4 However, it\u2019s read-only: >>> tags [ 0 ] = \"bob\" \u2026 TypeError: 'Tags' object does not support item assignment","title":"Files, users, tags"},{"location":"development/adding-an-object.html","text":"Adding a new object type This will show the process by which we can add support for Space objects, but it should be roughly applicable to other objects. Skeleton Start by creating a new file in viscera . Following the example of existing objects, name it maas/client/viscera/spaces.py (i.e. plural). Why viscera ? The client we recommend for users is a fa\u00e7ade of viscera , allowing us to present a simplified interface which mingles set-like operations with individual ones. This is friendlier to a new developer, but viscera itself keeps the two separate for cleanliness of implementation. Create a skeleton for Space and Spaces : \"\"\"Objects for spaces.\"\"\" __all__ = [ \"Space\" , \"Spaces\" , ] from . import ( Object , ObjectSet , ObjectType , ) class SpacesType ( ObjectType ): \"\"\"Metaclass for `Spaces`.\"\"\" class Spaces ( ObjectSet , metaclass = SpacesType ): \"\"\"The set of spaces.\"\"\" class SpaceType ( ObjectType ): \"\"\"Metaclass for `Space`.\"\"\" class Space ( Object , metaclass = SpaceType ): \"\"\"A space.\"\"\" We create explicit type classes as a place to put class-specific information and methods. Most interestingly, methods created on the type classes are class methods on instances of the type. For example: >>> class FooType ( type ): ... def hello ( cls ): ... return \"Hello, %s \" % cls >>> class Foo ( metaclass = FooType ): ... def goodbye ( self ): ... return \"Goodbye, %s \" % self >>> Foo . hello () \"Hello, <class '__main__.Foo'>\" >>> foo = Foo () >>> foo . goodbye () 'Goodbye, <__main__.Foo object at ...>' The difference between using @classmethod and this is that those class methods are not available on instances: >>> foo . hello () Traceback (most recent call last): ... AttributeError : 'Foo' object has no attribute 'hello' This keeps the namespace uncluttered, which is good for interactive, exploratory development, and it keeps code cleaner too: a class method must be called via the class. Getting this into the default Origin In maas/client/viscera/__init__.py is the default Origin class. This loads object definitions, like those above, and binds them to a particular server. More about that later, but for now you need to add \".spaces\" to Origin.__init__ : \".files\", \".maas\", \".machines\", + \".spaces\", \".tags\", \".users\", \".version\", Basic accessors Add the following basic accessor method to SpacesType : class SpacesType ( ObjectType ): async def read ( cls ): data = await cls . _handler . read () return cls ( map ( cls . _object , data )) Let\u2019s start working against a real MAAS server: $ bin/maas login my-server http://.../MAAS username p4ssw0rd $ bin/pip install -IU IPython # Don't leave home without it. $ bin/maas shell --viscera Welcome to the MAAS shell. Predefined objects: client: A pre-canned client for 'madagascar'. origin: A pre-canned `viscera` origin for 'madagascar'. >>> origin . Spaces . read () <Spaces length=2 items=[<Space>, <Space>]> >>> origin . Spaces . _handler <Handler Spaces http://.../MAAS/api/2.0/spaces/> >>> origin . Spaces . _origin <maas.client.viscera.Origin at ...> The _handler attribute is the bones handler for spaces. We named the class \u201cSpaces\u201d and Origin paired that up with the bones handler of the same name. This let us call the lower-level read() method. Try calling it now: >>> origin . Spaces . _handler . read () [{'id': 0, 'name': 'space-0', 'resource_uri': '/MAAS/api/2.0/spaces/0/', 'subnets': [], 'vlans': []}, {'id': -1, 'name': 'undefined', 'resource_uri': '/MAAS/api/2.0/spaces/undefined/', 'subnets': [{'active_discovery': False, 'allow_proxy': True, 'cidr': '192.168.1.0/24', 'dns_servers': [], 'gateway_ip': '192.168.1.254', 'id': 1, 'managed': True, 'name': '192.168.1.0/24', 'rdns_mode': 2, 'resource_uri': '/MAAS/api/2.0/subnets/1/', 'space': 'undefined', 'vlan': {'dhcp_on': True, 'external_dhcp': None, 'fabric': 'fabric-0', 'fabric_id': 0, 'id': 5001, 'mtu': 1500, 'name': 'untagged', 'primary_rack': '4y3h7n', 'relay_vlan': None, 'resource_uri': '/MAAS/api/2.0/vlans/5001/', 'secondary_rack': 'xfaxgw', 'space': 'undefined', 'vid': 0}}], 'vlans': [{'dhcp_on': True, 'external_dhcp': None, 'fabric': 'fabric-0', 'fabric_id': 0, 'id': 5001, 'mtu': 1500, 'name': 'untagged', 'primary_rack': '4y3h7n', 'relay_vlan': None, 'resource_uri': '/MAAS/api/2.0/vlans/5001/', 'secondary_rack': 'xfaxgw', 'space': 'undefined', 'vid': 0}]}] Lots of information! By the way, many or most of the IO methods in python-libmaas can be called interactively or in a script and they work the same as any other synchronous or blocking call. Internally, however, they\u2019re all asynchronous. They\u2019re wrapped in such a way that, when called from outside of an asyncio event-loop, they block, but inside they work just the same as any other asynchronous call. Let\u2019s look at those Space objects: >>> space , * _ = origin . Spaces . read () >>> dir ( space ) [..., '_data', '_handler', '_origin'] >>> space . _data {'id': 0, 'name': 'space-0', 'resource_uri': '/MAAS/api/2.0/spaces/0/', 'subnets': [], 'vlans': []} >>> space . _handler <Handler Space http://madagascar.local:5240/MAAS/api/2.0/spaces/{space_id}/> >>> space . _origin is origin True The handler has been associated with this object type like it was for Spaces , so now\u2019s a good time to add another accessor method: class SpaceType ( ObjectType ): async def read ( cls ): data = await cls . _handler . read () return cls ( data ) Try it out: >>> space = origin . Space . read ( 0 ) >>> space . _data {'id': 0, 'name': 'space-0', 'resource_uri': '/MAAS/api/2.0/spaces/0/', 'subnets': [], 'vlans': []} Getting at the data We don\u2019t want to work with that _data dictionary, we want attributes: class Space ( Object , metaclass = SpaceType ): \"\"\"A space.\"\"\" id = ObjectField . Checked ( \"id\" , check ( int ), readonly = True ) name = ObjectField . Checked ( \"name\" , check ( str ), readonly = True ) Try it out in the shell: >>> space . id , space , name (0, 'space-0') Next steps That\u2019s enough for now, but there\u2019s plenty of ground yet to be covered: How to work with the information about subnets and VLANs data that was returned. How to create, modify, and delete objects. How to test all of this.","title":"Adding an object"},{"location":"development/adding-an-object.html#skeleton","text":"Start by creating a new file in viscera . Following the example of existing objects, name it maas/client/viscera/spaces.py (i.e. plural). Why viscera ? The client we recommend for users is a fa\u00e7ade of viscera , allowing us to present a simplified interface which mingles set-like operations with individual ones. This is friendlier to a new developer, but viscera itself keeps the two separate for cleanliness of implementation. Create a skeleton for Space and Spaces : \"\"\"Objects for spaces.\"\"\" __all__ = [ \"Space\" , \"Spaces\" , ] from . import ( Object , ObjectSet , ObjectType , ) class SpacesType ( ObjectType ): \"\"\"Metaclass for `Spaces`.\"\"\" class Spaces ( ObjectSet , metaclass = SpacesType ): \"\"\"The set of spaces.\"\"\" class SpaceType ( ObjectType ): \"\"\"Metaclass for `Space`.\"\"\" class Space ( Object , metaclass = SpaceType ): \"\"\"A space.\"\"\" We create explicit type classes as a place to put class-specific information and methods. Most interestingly, methods created on the type classes are class methods on instances of the type. For example: >>> class FooType ( type ): ... def hello ( cls ): ... return \"Hello, %s \" % cls >>> class Foo ( metaclass = FooType ): ... def goodbye ( self ): ... return \"Goodbye, %s \" % self >>> Foo . hello () \"Hello, <class '__main__.Foo'>\" >>> foo = Foo () >>> foo . goodbye () 'Goodbye, <__main__.Foo object at ...>' The difference between using @classmethod and this is that those class methods are not available on instances: >>> foo . hello () Traceback (most recent call last): ... AttributeError : 'Foo' object has no attribute 'hello' This keeps the namespace uncluttered, which is good for interactive, exploratory development, and it keeps code cleaner too: a class method must be called via the class.","title":"Skeleton"},{"location":"development/adding-an-object.html#getting-this-into-the-default-origin","text":"In maas/client/viscera/__init__.py is the default Origin class. This loads object definitions, like those above, and binds them to a particular server. More about that later, but for now you need to add \".spaces\" to Origin.__init__ : \".files\", \".maas\", \".machines\", + \".spaces\", \".tags\", \".users\", \".version\",","title":"Getting this into the default Origin"},{"location":"development/adding-an-object.html#basic-accessors","text":"Add the following basic accessor method to SpacesType : class SpacesType ( ObjectType ): async def read ( cls ): data = await cls . _handler . read () return cls ( map ( cls . _object , data )) Let\u2019s start working against a real MAAS server: $ bin/maas login my-server http://.../MAAS username p4ssw0rd $ bin/pip install -IU IPython # Don't leave home without it. $ bin/maas shell --viscera Welcome to the MAAS shell. Predefined objects: client: A pre-canned client for 'madagascar'. origin: A pre-canned `viscera` origin for 'madagascar'. >>> origin . Spaces . read () <Spaces length=2 items=[<Space>, <Space>]> >>> origin . Spaces . _handler <Handler Spaces http://.../MAAS/api/2.0/spaces/> >>> origin . Spaces . _origin <maas.client.viscera.Origin at ...> The _handler attribute is the bones handler for spaces. We named the class \u201cSpaces\u201d and Origin paired that up with the bones handler of the same name. This let us call the lower-level read() method. Try calling it now: >>> origin . Spaces . _handler . read () [{'id': 0, 'name': 'space-0', 'resource_uri': '/MAAS/api/2.0/spaces/0/', 'subnets': [], 'vlans': []}, {'id': -1, 'name': 'undefined', 'resource_uri': '/MAAS/api/2.0/spaces/undefined/', 'subnets': [{'active_discovery': False, 'allow_proxy': True, 'cidr': '192.168.1.0/24', 'dns_servers': [], 'gateway_ip': '192.168.1.254', 'id': 1, 'managed': True, 'name': '192.168.1.0/24', 'rdns_mode': 2, 'resource_uri': '/MAAS/api/2.0/subnets/1/', 'space': 'undefined', 'vlan': {'dhcp_on': True, 'external_dhcp': None, 'fabric': 'fabric-0', 'fabric_id': 0, 'id': 5001, 'mtu': 1500, 'name': 'untagged', 'primary_rack': '4y3h7n', 'relay_vlan': None, 'resource_uri': '/MAAS/api/2.0/vlans/5001/', 'secondary_rack': 'xfaxgw', 'space': 'undefined', 'vid': 0}}], 'vlans': [{'dhcp_on': True, 'external_dhcp': None, 'fabric': 'fabric-0', 'fabric_id': 0, 'id': 5001, 'mtu': 1500, 'name': 'untagged', 'primary_rack': '4y3h7n', 'relay_vlan': None, 'resource_uri': '/MAAS/api/2.0/vlans/5001/', 'secondary_rack': 'xfaxgw', 'space': 'undefined', 'vid': 0}]}] Lots of information! By the way, many or most of the IO methods in python-libmaas can be called interactively or in a script and they work the same as any other synchronous or blocking call. Internally, however, they\u2019re all asynchronous. They\u2019re wrapped in such a way that, when called from outside of an asyncio event-loop, they block, but inside they work just the same as any other asynchronous call. Let\u2019s look at those Space objects: >>> space , * _ = origin . Spaces . read () >>> dir ( space ) [..., '_data', '_handler', '_origin'] >>> space . _data {'id': 0, 'name': 'space-0', 'resource_uri': '/MAAS/api/2.0/spaces/0/', 'subnets': [], 'vlans': []} >>> space . _handler <Handler Space http://madagascar.local:5240/MAAS/api/2.0/spaces/{space_id}/> >>> space . _origin is origin True The handler has been associated with this object type like it was for Spaces , so now\u2019s a good time to add another accessor method: class SpaceType ( ObjectType ): async def read ( cls ): data = await cls . _handler . read () return cls ( data ) Try it out: >>> space = origin . Space . read ( 0 ) >>> space . _data {'id': 0, 'name': 'space-0', 'resource_uri': '/MAAS/api/2.0/spaces/0/', 'subnets': [], 'vlans': []}","title":"Basic accessors"},{"location":"development/adding-an-object.html#getting-at-the-data","text":"We don\u2019t want to work with that _data dictionary, we want attributes: class Space ( Object , metaclass = SpaceType ): \"\"\"A space.\"\"\" id = ObjectField . Checked ( \"id\" , check ( int ), readonly = True ) name = ObjectField . Checked ( \"name\" , check ( str ), readonly = True ) Try it out in the shell: >>> space . id , space , name (0, 'space-0')","title":"Getting at the data"},{"location":"development/adding-an-object.html#next-steps","text":"That\u2019s enough for now, but there\u2019s plenty of ground yet to be covered: How to work with the information about subnets and VLANs data that was returned. How to create, modify, and delete objects. How to test all of this.","title":"Next steps"},{"location":"development/releasing.html","text":"Releasing a new version of python-libmaas Clean and test: make clean make test If you didn\u2019t make clean just now, do it! Without it the PyPI uploads may be built incorrectly. Bump version in setup.py , merge to master . Tag master : git tag --sign ${ version } --message \"Release ${ version } .\" git push origin --tags Build and push docs to GitHub : make docs-to-github Build and push source and wheel to PyPI : make upload","title":"Release checklist"}]}